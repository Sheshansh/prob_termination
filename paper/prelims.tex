
\vspace{-1em}
\section{Preliminaries}\label{sec:prelim}

We use a standard notation in the field of probabilistic program 
analysis~\cite{CNZ17}.

\vspace{-1em}
\subsection{Basic Notions}
\vspace{-0.5em}
For a set $A$ we denote by $|A|$ the cardinality of $A$. We denote by $\Nset$,
$\Nset_0$, $\Zset$, and $\Rset$ the sets of all positive integers, non-negative
integers, integers, and real numbers, respectively. We assume basic knowledge 
of matrix calculus.
We use boldface notation for
vectors, e.g. $\vec{x}$, $\vec{y}$, etc., and we denote an $i$-th component of a
vector $\vec{x}$ by $\vec{x}[i]$. 
%For the purpose of matrix calculations we 
%assume that (non-transposed) vectors are row vectors. If $\vec{v},\vec{v}'$ 
%are 
%$n$ and $m$ dimensional vectors, respectively, then $(\vec{v},\vec{v}')$ is an 
%$(n+m)$-dimensional vector obtained by ``concatenation'' of $\vec{v}$ and 
%$\vec{v}'$. 
We identify 1-dimensional vectors with numbers. For an 
$n$-dimensional vector 
$\vec{x}$, index $1 \leq i\leq n$, and number $a$ we denote by $\vec{x}(i\leftarrow a)$ 
a 
vector $\vec{y}$ such that $\vec{y}[i]=a$ and $\vec{y}[j]=\vec{x}[j]$ for all 
$1\leq j \leq n$, $j\neq i$.
For comparison of vectors (e.g. as in $\vec{x}\leq \vec{y}$), we consider componentwise 
comparison. 
For comparing functions $f,g$ with the same domains, we write $f\leq g$ 
if $f(x)\leq g(x)$ for all $x$ in the domain. 
%\smallskip\noindent{\em Variables.}
Throughout the paper we fix a countable set of variables $\vars$. 
We consider some arbitrary but fixed linear order on the set of all variables, 
hence we write 
$\vars=\{x_1,x_2,x_3,\dots\}$. 
%A \emph{valuation} is a partial function 
%$\val\colon 
%\vars \dashrightarrow \Rset$ assigning a unique number to some of the 
%variables. A \emph{domain} of a valuation $\val$, denoted by %$\dom(\val)$, is 
%the set of all variables $x$ such that $\val(x)$ is defined. Given a %set 
%$\pvars\subseteq \vars$ of variables, we denote by $\vals(\pvars)$ the %set of 
%all valuations $\val$ with $\dom(\val)=\pvars$.


%\smallskip\noindent{\em Expressions.}
%An \emph{expression} over the set of variables $\{x_1,\dots,x_n\}$ 
%is an expression in the standard programming-language sense, i.e. a formula 
%built in finite number of steps from constants, variables $x_1,\dots,x_n$, and 
%numerical operators from some fixed finite set. Each expression $E$ over 
%$\{x_1,\dots,x_n\}$ 
%determines a function which for each $m$-dimensional vector $\vec{x}$, where 
%$m\geq n$,  
%returns a number resulting from substituting each $x_i$ in $E$ by $\vec{x}[i]$. 
%Slightly abusing our notation, we denote this function also by $E$ and the 
%value of this function on argument $\vec{x}$ by $E(\vec{x})$. 
%%An expression $E$ 
%%is \emph{measurable} if the function $E(\vec{x})$ is Borel 
%%measurable~\cite{xxx}.  In particular, expressions built using the standard 
%%arithmetic operators  are all measurable.
%
%\smallskip\noindent{\em Affine Expressions.}
%An \emph{affine expression} over the set of variables $\{x_1,\dots,x_n\}$ is an 
%expression of the form $d+\sum_{i=1}^{n}a_i
%x_i$, where  $d,a_1,\dots,a_n$ are real-valued
%constants.  A function of the form $E(\vec{x})$ for some affine expression $E$ 
%is called affine.
%%Following the terminology of~\cite{DBLP:conf/sas/KatoenMMM10} we fix the
%%following nomenclature
%
%\smallskip\noindent{\em Predicates}
%A \emph{predicate} is a logical formula obtained by a finite number of applications of conjunction, disjunction and negation operations on \emph{atomic predicates} of the form $E(\vec{x})\leq E'(\vec{y})$, where $E$, $E'$ are expressions.
%
%\smallskip\noindent{\em Linear constraints, assertions, predicates.}
%In the case of predicates involving only linear expression we use the following nomenclature:
%\begin{compactitem}
%\item {\em Linear Constraint.} A \emph{linear constraint} is a formula of the
%form $\psi$ or $\neg\psi$, where  $\psi$ is a non-strict inequality
%between affine expressions.
%\item {\em Linear Assertion.} A \emph{linear assertion} is a finite conjunction
%of linear constraints.
%\item {\em Propositionally Linear Predicate.}
%A  \emph{propositionally linear predicate} (PLP) is a finite disjunction of
%linear assertions.
%\end{compactitem}
%
%\noindent{\em Arity and satisfaction of PLP.}
%%The \emph{arity} of a PLP is the number of distinct variables appearing in it. 
%For a PLP $\varphi$ we denote by $\vars(\varphi)$ the set of all variables that 
%appear in $\varphi$. As noted above, we stipulate that $\vars(\varphi)=\{x_1,\dots,x_{n(\varphi)}\}$ for some $n(\varphi)\in \Nset$. A vector $\vec{x}$ of dimension $m\geq n(\varphi)$ \emph{satisfies} $\varphi$, we write 
%$\vec{x}\models\phi$, if 
% the arithmetic formula obtained by 
%substituting each occurrence of a variable $x_i$ in $\varphi$ by $\vec{x}[i]$ is 
%valid. We denote $\sat{\phi} = \{\vec{x}\in \Rset^m\mid m\geq n(\varphi) \wedge \vec{x} \models\phi\}$ 
%and $\exsat{\phi} = \sat{\phi}
%\cap \Rset^{n(\varphi)}$. 


%In this paper, we deem any linear assertion equivalently as a polyhedron
%defined by the linear assertion (i.e., the set of points satisfying the
%assertion).
%It will be always clear from the context whether a linear assertion is deemed
%as a logical formula or as a polyhedron.


\vspace{-1em}
\subsection{Syntax of Probabilistic Programs}\label{subsec:syntax}
\vspace{-0.5em}

In this subsection we define the form of probabilistic programs that we 
consider in our analysis. 
We consider two classes of probabilistic programs: 
general probabilistic programs (\PP{}s) with arbitrary (measurable) 
expressions and 
their subclass, affine probabilistic programs (\APP s) where all expressions 
are restricted to be affine (see below for a precise definition). The reason 
for this dual view is that our work also has two main points of focus: a 
theoretical one, where we introduce new concepts that can be used to prove 
properties of general probabilistic programs; and an algorithmic one, where we 
aim to prove properties of probabilistic programs automatically, using the 
aforementioned concepts. As already testified in the non-probabilistic 
world, programs that contain only affine expressions allow for more efficient 
automation of the analysis and at the same time, due to the presence of 
non-determinism they can be used to form sound abstractions of programs with 
non-linear arithmetic. Hence, we consider general programs when providing our 
theoretical results and \APP s when presenting the automation of our techniques.

\smallskip\noindent{\em Expressions.}
An \emph{expression} over the set of variables $\{x_1,\dots,x_n\}$ 
is an expression in the standard programming-language sense, i.e. a formula 
built in finite number of steps from constants, variables $x_1,\dots,x_n$, and 
numerical operators from some fixed finite set. Each expression $E$ over 
$\{x_1,\dots,x_n\}$ 
determines a function which for each $m$-dimensional vector $\vec{x}$, where 
$m\geq n$,  
returns a number resulting from substituting each $x_i$ in $E$ by $\vec{x}[i]$. 
Slightly abusing our notation, we denote this function also by $E$ and the 
value of this function on argument $\vec{x}$ by $E(\vec{x})$. We do not a priori fix a concrete set of operators that can be used to form expressions. However, in order to ensure that semantics of probabilistic programs with real-valued variables is defined correctly, we impose the following two conditions on the set of expressions used in each program:
%\begin{enumerate}
(1)
For each expression $E$ over variables $\{x_1,\dots,x_n\}$ and each $n$-dimensional vector $\vec{x}$ the value $E(\vec{x})$ is well defined.\footnote{Our results can be easily extended to programs where encountering an expression of undefined value, such as division by zero, triggers an exception which terminates the program, but we abstract away from such details for the sake of clarity.}
(2)
The function defined by each expression $E$ is Borel-measurable (for definition of Borel-measura\-bility, see, e.g.~\cite{Billingsley:book}).
%\end{enumerate}
%
From measure theory it is known that these conditions hold in particular for programs where expressions are build using the standard arithmetic operators of addition, subtraction, multiplication, and division (provided that expressions evaluating to zero are not allowed as divisors).

%An expression $E$ 
%is \emph{measurable} if the function $E(\vec{x})$ is Borel 
%measurable~\cite{xxx}.  In particular, expressions built using the standard 
%arithmetic operators  are all measurable.

\smallskip\noindent{\em Affine Expressions.}
An \emph{affine expression} over the set of variables $\{x_1,\dots,x_n\}$ is an 
expression of the form $d+\sum_{i=1}^{n}a_i
x_i$, where  $d,a_1,\dots,a_n$ are real-valued
constants.  A function of the form $E(\vec{x})$ for some affine expression $E$ 
is called affine. As noted above, each affine function is Borel-measurable.
%Following the terminology of~\cite{DBLP:conf/sas/KatoenMMM10} we fix the
%following nomenclature

\smallskip\noindent{\em Predicates.}
A \emph{predicate} is a logical formula obtained by a finite number of 
applications of conjunction, disjunction and negation operations on 
\emph{atomic predicates} of the form $E\leq E'$, where $E$, $E'$ are 
expressions. We denote by $\vec{x}\models E$ the fact that $E$ is satisfied by 
substituting values from of $\vec{x}$ for the corresponding variables in $E$.

\smallskip\noindent{\em Linear constraints, assertions, predicates.}
In the case of predicates involving only linear expression we use the following 
standard nomenclature:
\begin{compactitem}
	\item {\em Linear Constraint.} A \emph{linear constraint} is a formula of the
	form $\psi$ or $\neg\psi$, where  $\psi$ is a non-strict inequality
	between affine expressions.
	\item {\em Linear Assertion.} A \emph{linear assertion} is a finite conjunction
	of linear constraints.
	\item {\em Propositionally Linear Predicate.}
	A  \emph{propositionally linear predicate} (PLP) is a finite disjunction of
	linear assertions.
\end{compactitem}

%\textbf{[PETR: SAY SOMETHING ABOUT PREDICATE SATISFACTION.]}
%\textbf{[PETR: EXPLAIN BOREL-MEASURABILITY IN MORE DETAIL?]}

%\noindent{\em Arity and satisfaction of PLP.}
%%The \emph{arity} of a PLP is the number of distinct variables appearing in it. 
%For a PLP $\varphi$ we denote by $\vars(\varphi)$ the set of all variables that 
%appear in $\varphi$. As noted above, we stipulate that $\vars(\varphi)=\{x_1,\dots,x_{n(\varphi)}\}$ for some $n(\varphi)\in \Nset$. A vector $\vec{x}$ of dimension $m\geq n(\varphi)$ \emph{satisfies} $\varphi$, we write 
%$\vec{x}\models\phi$, if 
%the arithmetic formula obtained by 
%substituting each occurrence of a variable $x_i$ in $\varphi$ by $\vec{x}[i]$ is 
%valid. We denote $\sat{\phi} = \{\vec{x}\in \Rset^m\mid m\geq n(\varphi) \wedge \vec{x} \models\phi\}$ 
%and $\exsat{\phi} = \sat{\phi}
%\cap \Rset^{n(\varphi)}$. 

\noindent{\em The Syntax of Probabilistic Programs {(\PP s)}.}
We consider the standard syntax for probabilistic programs,
which encompasses basic programming mechanisms such as assignment statement 
(indicated by `:='), while-loop, if-branch. Expressions appear on right-hand sides of assignments, and predicates act as loop guards and conditions in if-then-else statements. We also consider basic probabilistic mechanisms 
such as probabilistic branch (indicated by `prob') and random sampling (e.g. 
$x:=\textbf{sample(}\mathrm{Uniform}[-2,1]\textbf{)}$ assigns to $x$ a random 
number 
uniformly sampled from interval $[-2,1]$). We also allow constructs for 
(demonic) non-determinism, in particular 
non-deterministic branching indicated by `\textbf{if }$\star$ \textbf{then...}' construct and non-deterministic assignment.  
Variables (or identifiers) of a probabilistic program are of \emph{real} type, i.e., 
values of the variables are real numbers. 
We also assume that each \PP{} $\program$ is preceded by a preamble 
specifying possible initial values of program variables: the preamble consists 
of a single predicate characterizing possible initial valuations.

\smallskip\noindent{\em Affine Probabilistic Programs (\APP s).}
A probabilistic program is \emph{affine} if all the expressions that occur in 
the program (i.e. in loop guards, conditionals, right-hand sides of 
assignments) are affine and if the set of possible initial valuations is a 
polyhedron. We refer to the class of affine probabilistic programs 
as \APP s.
%We also assume that assume that each \APP{} $\program$ is preceded by an 
%initialization preamble 
%in 
%which 
%each variable appearing in $\program$ is assigned some concrete number.
%the program variables are initialized.

Due to space restrictions, details of syntax (such as grammar) are relegated to 
\AppendixMaterial.
For an example see Figure~\ref{fig:invariant-running}.




\vspace{-1em}
\subsection{Semantics of Probabilistic Programs}\label{subsec:semantics}
\vspace{-0.5em}

We now formally define the semantics of \PP's.
In order to do this, we first recall some fundamental concepts from probability
theory.

\smallskip\noindent{\em Basics of Probability Theory.}
%%We now recall basic definitions of probability theory.
 A probability space is a triple
$(\Omega,\mathcal{F},\probm)$, where $\Omega$ is a non-empty set (so called
\emph{sample space}), $\mathcal{F}$ is a \emph{sigma-algebra} of measurable 
sets over $\Omega$,
i.e. a collection of subsets of $\Omega$ that contains the empty set
$\emptyset$, and that is closed under complementation and countable unions, and
$\probm$ is a \emph{probability measure} on $\mathcal{F}$, i.e., a function
$\probm\colon \mathcal{F}\rightarrow[0,1]$ such that:
%\begin{compactitem}
(1) $\probm(\emptyset)=0$,
(2) for all $A\in \mathcal{F}$ it holds $\probm(\Omega\smallsetminus
A)=1-\probm(A)$, and
(3) for all pairwise disjoint countable set sequences $A_1,A_2,\dots \in
\mathcal{F}$ (i.e., $A_i \cap A_j = \emptyset$ for all $i\neq j$)
we have $\sum_{i=1}^{\infty}\probm(A_i)=\probm(\bigcup_{i=1}^{\infty} A_i)$.
%\end{compactitem}

Following the usual probabilistic terminology, we say that \emph{almost all} $\omega$ belonging to some set $O\subseteq \Omega$ satisfy some property $\Psi$ if it holds that $\probm{(\{\omega\in O\mid \omega \text{ does not satisfy }\Psi\})}=0$.

\noindent{\em Random variables and filtrations.}
A \emph{random variable} in a probability space $(\Omega,\mathcal{F},\probm)$ is
an $\mathcal{F}$-measurable function $R\colon \Omega \rightarrow \Rset \cup
\{\infty\}$, i.e.,
a function such that for every $a\in \Rset \cup \{ \infty\}$ the set
$\{\omega\in \Omega\mid R(\omega)\leq a\}$ belongs to $\mathcal{F}$. If 
$R(\omega)\in \Rset$ for all $\omega\in \Omega$, we say that $R$ is 
\emph{real-valued.}
We denote by $\expv[R]$ the \emph{expected value} of a random variable $X$~(see \cite[Chapter 5]{Billingsley:book}
for a formal definition). 
%%i.e.
%%the Lebesgue integral of $X$ with respect to the probability measure $\probm$.
%%The precise definition of the Lebesgue integral of $R$ is somewhat technical and
%%we omit it here, see,
%%e.g., ~\cite[Chapter 4]{Rosenthal:book}, or~\cite[Chapter 5]{Billingsley:book}
%for a formal definition. 
A \emph{random vector} in $(\Omega,\mathcal{F},\probm)$ is a vector whose every component is a random 
variable in this probability space. A \emph{stochastic process} in a 
probability space $(\Omega,\mathcal{F},\probm)$ is an infinite sequence of 
random vectors in this space.
We will also use random variables of the form $R\colon\Omega \rightarrow S$ for some finite 
set $S$, which is easily translated to the variables above.
A \emph{filtration} of a sigma-algebra $\mathcal{F}$ is a
sequence $\{\mathcal{F}_i \}_{i=0}^{\infty}$ of $\sigma$-algebras 
such that $\mathcal{F}_0 \subseteq \mathcal{F}_1 \subseteq \cdots \subseteq
\mathcal{F}_n \subseteq \cdots \subseteq \mathcal{F}$.

\emph{Distributions.} We assume the standard definition of a probability 
distribution specified by a cumulative distribution 
function~\cite{Billingsley:book}. We denote by $\mathcal{D}$ the set of 
probability distributions on 
real numbers, both discrete and continuous.

\noindent{\em Probabilistic Control Flow Graphs.}
%There are several ways in which one can express the semantics of \APP's with
%(angelic and demonic) 
%non-determinism
We consider standard operational semantics of \PP{}s defined via an 
uncountable state-space
Markov decision process (MDP) (uncountable due to real-valued variables).
That is, we associate to each program 
a certain stochastic process.
To define this process, we first define so called 
\emph{probabilistic control flow graphs}~\cite{CFG16}.


\begin{definition}
\label{def:stochgame}
A \emph{probabilistic control flow graph (pCFG)} is a tuple
$\pCFG=(\locs,\pvars,\locinit,\vecinitset,\transitions,\updates,\probdist,\guards)$,
where
\begin{compactitem}
\item $\locs$ is a finite set of \emph{locations} partitioned into four 
pairwise
disjoint subsets  $\locsNB$, $\locsPB$, $\locs_D$, and $\locs_A$ of 
non-deterministic branching, 
probabilistic branching, deterministic, and assignment locations;
\item $\pvars=\{x_1,\dots,x_{|\pvars|}\}$ is a finite set of \emph{program 
variables} (note that $\pvars \subseteq \vars$) ;
\item $\locinit$ is an initial location and $\vecinitset$ is a set of initial 
\emph{assignment vectors};
% POKRACOVAT ODSUD
\item $\transitions\subseteq\locs\times\locs$ is a transition relation;
%whose members are tuples of
%the form $(\ell,i,\up,\ell')$, where $\ell$ and $\ell'$ are source and target
%program locations, respectively, $1\leq i \leq |\pvars|$ is a \emph{target 
%variable index}, and $u$ 
%is an 
%\emph{update element}, which can 
%be one of the following mathematical objects: %\begin{itemize}
%%\item 
%(a)~an affine function $u\colon \Rset^{|\pvars|}\rightarrow \Rset$;
%%\item 
%(b)~a distribution $d\in \mathcal{D}$; or
%%%\item 
%(c)~a set $R\subseteq \Rset$.
%\end{itemize}
\item $\updates$ is a function assigning to each transition outgoing from an 
assignment location a tuple $(i,\up)$, where $1\leq i \leq |\pvars|$ is a 
\emph{target 
	variable index} and $\up$ 
is an 
\emph{update element}, which can 
be one of the following mathematical objects: %\begin{itemize}
%\item 
(a)~a Borel-measurable function $u\colon \Rset^{|\pvars|}\rightarrow \Rset$;
%\item 
(b)~a distribution $d\in \mathcal{D}$; or
%\item 
(c)~a set $R\subseteq \Rset$ (representing a non-deterministic update).
%\end{itemize}
\item $\probdist=\{\prob_{\ell}\}_{\ell \in \locsPB}$ is a collection of
probability distributions, where each $\prob_{\ell}$ is a discrete probability
distribution on the set of all transitions outgoing from~$\ell$;
\item $\guards$ is a function assigning a propositionally linear predicate
(a \emph{guard}) over $\pvars$ to each transition outgoing from a deterministic 
location.
\end{compactitem}

We assume that each location has at least one outgoing transition.
Also, for every deterministic location $\ell$ we assume the following: if
$\tau_1,\dots,\tau_k$ are all transitions outgoing from $\ell$, then $G(\tau_1)
\vee \dots \vee G(\tau_k) \equiv \mathit{true}$ and $G(\tau_i) \wedge G(\tau_j)
\equiv \mathit{false}$ for each $1\leq i < j \leq k$. For each 
distribution $d$ appearing in the 
pCFG we assume the following features are known: expected value $\expv[d]$ of 
$d$ and a set $SP_d$ containing the \emph{support} of $d$. The support is the  
smallest 
closed set of real numbers whose complement has probability zero 
under $d$.\footnote{In particular, a support of a \emph{discrete} probability 
	distribution $d$ is simply the at most countable set of all points on a 
	real 
	line that have positive probability under $d$.} Finally, we assume that 
	each 
assignment location has at most (and thus exactly) one outgoing transition. The 
translation from probabilistic programs to the corresponding pCFG is 
standard~\cite{CFNH16:prob-termination}, and the details are presented 
in~\AppendixMaterial.
%Finally, we assume that for each 
%transition $(\loc,j,u,\loc')$ such that $u$ is a set the location $\loc$ is 
%deterministic. This is just a technical assumption yielding no loss of 
%generality, and it somewhat simplifies notation.
%And we assume that each coordinate of $\mathcal{D}$ represents an integrable
%random variable (i.e., the expected value of the absolute value of the random
%variable exists).
\end{definition}
\noindent{\em Configurations.}
A \emph{configuration} of a pCFG $\pCFG$ is a tuple $(\ell,\vec{x})$,
where $\ell$ is a location of $\pCFG$ and $\vec{x}$ is an 
$|\pvars|$-dimensional vector.
We say that a transition $\tau$ is \emph{enabled} in a configuration
$(\ell,\vec{x})$ if $\ell$ is the source location of $\tau$ and in addition,
${\vec{x}}\models G(\tau)$ provided that $\ell$ is deterministic. 
%A 
%configuration 
%$(\loc,\vec{x})$ is non-deterministic/probabilistic/deterministic/assignment 
%one if 
%$\loc$ is 
%non-deterministic/probabilistic/deterministic/assignment one, respectively.

\noindent{\em Executions and reachable configurations.}
We say that a configuration $(\loc',\vec{x}')$ is a \emph{successor} of a 
configuration $(\loc,\vec{x})$ if 
%A \emph{finite path} (or
%\emph{execution fragment}) of length $k$ in $\pCFG$ is a finite sequence of
%configurations $(\ell_0,\vec{x}_0)\cdots(\ell_k,\vec{x}_k)$ such that 
%%$(\loc_0,\vec{x}_0)=(\locinit,\vecinit)$ and 
%for each
%$0 \leq i < k$ 
there is a transition  $\tau=(\loc,\loc')$ enabled in
$(\loc,\vec{x})$ 
%such that $\vec{x}_{i+1}=\vec{x}_i(j\leftarrow a)$ where $a$ 
%satisfies one of the following:
and $\vec{x}'$ satisfies the following:
\begin{compactitem}
\item if $\loc$ is not an assignment location, then $\vec{x}'=\vec{x}$;
\item if $\loc$ is an assignment location with $\updates(\tau)=(j,\up)$, then 
$\vec{x}_{i+1}=\vec{x}_i(j\leftarrow a)$ where $a$ satisfies one of the 
following 
depending on the type of $\up$:
%\begin{compactitem}
%\item 
(a)~if $\up$ is a Borel-measurable function, then $a=\up(\vec{x})$;
%\item 
(b)~if $\up$ is an integrable\footnote{A distribution on some numerical 
domain 
is integrable if its expected value exists and is finite. In particular, each 
Dirac distribution is integrable.} distribution $d$, then 
$a\in \support(d)$; and
%\item
(c)~if $\up$ is a set, then $a$ is some element of $\up$.
%\end{compactitem}
\end{compactitem}
A \emph{finite path} (or
\emph{execution fragment}) of length $k$ in $\pCFG$ is a finite sequence of
configurations $(\ell_0,\vec{x}_0)\cdots(\ell_k,\vec{x}_k)$ such that 
$\loc_0=\locinit$, $\vec{x}_0\in\vecinitset$, and 
%$(\loc_0,\vec{x}_0)=(\locinit,\vecinit)$ and 
for each
$0 \leq i < k$ the configuration $(\loc_{i+1},\vec{x}_{i+1})$ is a successor of 
$(\loc_i,\vec{x}_i)$.
A \emph{run} (or \emph{execution}) in
$\pCFG$ is an infinite sequence of configurations whose every finite
prefix is a finite path.
A configuration $(\loc,\vec{x})$ is {\em reachable} from the initial 
configuration
$(\locinit,\vecinit)$ (where, $\vecinit\in \vecinitset$)
if there is a finite path starting in $(\locinit,\vecinit)$ that ends in
$(\loc,\vec{x})$. We denote by $\Conf_\pCFG,\Fpath_\pCFG$ and $\Run_\pCFG$ the 
sets of all configurations, finite paths and runs in $\pCFG$, respectively, 
dropping the index $\pCFG$ when known from the context.


\smallskip\noindent{\em Non-determinism and Schedulers.}
%Due to the presence of non-determinism and probabilistic choices, a pCFG
%$\pCFG$ may represent a multitude of possible behaviours. 
The probabilistic
behaviour of $\pCFG$ can be captured by constructing a suitable
probability measure over the set of all its runs. Before this can be
done, non-determinism in $\pCFG$ needs to be resolved. This is achieved using 
the 
standard notion of a \emph{scheduler}. Note that there are two sources of 
non-determinism in our programs: one in branching and 
one in assignments. We call a location $\loc$ non-deterministic if $\loc$ is a 
non-deterministic branching location or if $\loc$ is an assignment location 
with the only transition $\tau$ outgoing from 
$\loc$ having a non-deterministic assignment. A configuration 
$(\loc,\vec{x})$ is non-deterministic if $\loc$ is non-deterministic.

\smallskip
\begin{definition}[Schedulers]
\label{def:schedulers}
A scheduler in a pCFG $\pCFG$ is a function $\sigma$
%(the subscripts stand for 'transition' and 'assignment')
%\begin{compactitem}
 assigning 
to every finite path that ends in a non-deterministic configuration 
$(\loc,\vec{x})$ a probability distribution on successor configurations of 
$(\loc,\vec{x})$.

%\end{compactitem}
%function
%which assigns to every finite path in $\mathcal{G}$ that ends in an angelic
%(resp., demonic) configuration $(\ell,\vec{x})$, respectively,
%a discrete probability distribution on transitions outgoing from~$\ell$.
%a transition outgoing from~$\ell$.
\end{definition}

\smallskip\noindent{\em Measurable schedulers.}
Note that schedulers can be viewed as partial functions from the set $\Fpath$ 
to the set of probability distributions over the set $\Conf$.
Since we deal with programs operating over real-valued variables, both $\Fpath$ 
and $\Conf$ can be uncountable sets. Hence, we impose an 
additional \emph{measurability} condition on schedulers, so as to ensure that 
the semantics of probabilistic non-deterministic programs is defined in a 
mathematically 
sound way. First we need to clarify what are measurable sets of configurations 
and histories. We define a sigma-algebra $\mathcal{F}_{\Conf}$ of measurable 
sets of configurations to be the sigma-algebra 
over $\Conf$ 
generated\footnote{In general, it is known that for each set $\Omega$ and each 
collection of its subsets $F\subseteq 2^{\Omega}$ there exists at least one 
sigma-algebra $\mathcal{F}$ s.t. $F\subseteq \mathcal{F}$ and the intersection 
of all such sigma-algebras is again a sigma algebra --  so called sigma-algebra 
generated by $F$~\cite{Billingsley:book}.} by 
all sets of the form $\{\loc\}\times B$, where $\loc$ is a location of $\pCFG$ 
and  
$B$ is a Borel-measurable subset 
of $\Rset^{|\pvars|}$. Next, the set of finite paths $\Fpath$ can be viewed as 
a subset of $\Conf\cup \Conf\times\Conf \cup \Conf\times\Conf\times\Conf \cup 
\dots$. Hence, we define the sigma-algebra $\mathcal{H}$ of measurable sets of 
finite paths 
to be the sigma algebra generated by all sets of the form $\confset_1\times 
\confset_2 \times 
\cdots \times \confset_k \subseteq \Fpath$ such that $k\in \Nset$ and 
$\confset_i \in 
\mathcal{F}_{\Conf}$ for 
all $1\leq i \leq k$. Now we can define the measurability of schedulers. Recall 
that for each finite path $\genpath$ ending in a non-deterministic 
configuration 
we have that $\sigma(\genpath)$ is a probability distribution on $\Conf$. For 
each measurable set of configurations $\confset$ we denote by 
$\sigma(\genpath)(\confset)$ the probability that the random draw from 
distribution $\sigma(\genpath)$ selects an element of $\confset$. We say that a 
scheduler $\sigma$ is measurable if for each $\confset \in \mathcal{F}_{\Conf}$ 
and each $p\in[0,1]$ the set $\{\pi \in \Fpath \mid 
\sigma(\genpath)(\confset)\leq p\}$ belongs to $\mathcal{H}$, i.e., it is a 
measurable set of paths.

While the definition of a measurable scheduler might seem somewhat technical, 
it is natural from measure-theoretic point of view and analogous definitions 
inevitably emerge in works dealing with systems that exhibit both probabilistic 
and non-deterministic behaviour over a continuous state 
space~\cite{NSK:CTMDP-delayed,NK:CTMDP-bisimulation}. In particular, if all the 
variables in a program range over a discrete set (such as the integers), 
then each scheduler in the associated pCFG is measurable.
%Formally, let 
%$\Borel(\Rset^{|\pvars|})$ be the standard sigma-algebra of Borel-measurable 
%subsets of $\Rset^{|\pvars|}$. Now let $\genPathSet$ be any set of finite 
%paths 
%in 
%$\pCFG$ and denote by $\proj_j (A)$ the set of all variable valuations that 
%appear on some path in $A$ in step $j$, i.e. $\proj_j(A) = 
%\{\vec{y}\in\Rset^{|\pvars|} \mid \exists  
%(\ell_0,\vec{x}_0)\cdots(\ell_k,\vec{x}_k) \in A \text{ s.t. } k \geq j \} $
%A \emph{measurable cylinder} of length 
%$k$ is a 
%set of paths $\cylinder_n$ in $\pCFG$ satisfying the following condition: 

%A scheduler $\sigma$ is \emph{memoryless} if $\sigmat(w)=\sigmat(w')$ whenever 
%the finite paths 
%$w$ and $w'$ end in the same configuration and if $\sigmaa(w)=\sigmaa(w')$ 
%whenever $w$ and $w'$ end with the same transition. A scheduler $\sigma$ is 
%\emph{deterministic} if for all $w,w'$ the distributions $\sigmaa(w)$ and 
%$\sigmat(w')$ are \emph{Dirac}, i.e. they assign probability 1 to a single 
%transition (resp. to a single number) and probability 0 to all the others.

\smallskip\noindent{\em Stochastic process.}
A pCFG $\pCFG$ together with a scheduler $\sigma$ and initial valuation 
$\vecinit\in\vecinitset$ define a stochastic 
process which produces a random run 
$(\loc_0,\vec{x}_0)(\loc_1,\vec{x}_1)(\loc_2,\vec{x}_2)\cdots$. The evolution 
of 
this process can be informally described as follows: we start in the initial 
configuration, i.e. $(\loc_{0},\vec{x}_0)=(\locinit,\vecinit)$. 
Now assume that $i$ 
steps have elapsed, i.e. a finite path 
$\genpath_i=(\loc_0,\vec{x}_0)(\loc_1,\vec{x}_1)\cdots(\loc_i,\vec{x}_i)$ has 
already 
been produced. Then a successor configuration $(\loc_{i+1},\vec{x}_{i+1})$ is 
chosen as follows:
\begin{compactitem}
\item
If $\loc_i$ is a non-deterministic location, then 
$(\loc_{i+1},\vec{x}_{i+1})$ is sampled according to scheduler $\sigma$, i.e. 
from 
the distribution $\sigma(\genpath_i)$.
\item
If $\loc_i$ is an assignment location (but not a non-deterministic one) with, 
there 
is exactly one transition $\tau=(\loc_i,\loc')$ outgoing from it and we put 
$\loc_{i+1}=\loc'$. Denoting $\updates(\tau)=(j,\up)$, the vector 
$\vec{x}_{i+1}$ is 
then defined as 
$\vec{x}_{i+1}=\vec{x}_{i}(j\leftarrow a)$ where $a$ is chosen depending on 
$\up$:
\begin{compactitem}
\item If $u$ is a function $u\colon
\Rset^{|\pvars|}\rightarrow \Rset$, then $a=f(\vec{x}_{i})$.
\item If $\up$ is a distribution $d$, then $a$ 
is sampled from $d$.
\end{compactitem}
\item In all other cases we have $\vec{x}_{i+1}=\vec{x}_i$, and $\loc_{i+1}$ is 
determined as follows:
\begin{itemize}
	\item If $\loc_i$ is a probabilistic branching location, then a transition 
	$(\loc_i,\loc')$ is sampled from $\probdist_{\loc_i}$ and we put
	$\loc_{i+1}=\loc'$;
	\item If $\loc_i$ is deterministic, then there is exactly one transition 
	$(\loc_i,\loc')$ enabled in $(\loc_i,\vec{x}_i)$, in which case we put 
	$\loc_{i+1}=\loc'$.
\end{itemize}
\end{compactitem}


%\begin{compactitem}
%\item
%a transition $\tau=(\loc_i,\loc')$ enabled in 
%$(\lr{}{i},\vr{}{i})$ is chosen as follows:
%
%\begin{compactitem}
%\item
%If $\ell_i$ is non-deterministic, then $\tau$ is chosen randomly
%according to the distribution specified
%by scheduler
%$\sigma$, i.e. according to distribution
%$\sigma((\loc_0,\vec{x}_0)(\loc_1,\vec{x}_1)\cdots(\loc_i,\vec{x}_i))$ 
%(formally, this is a distribution over successor configurations of 
%$(\loc_i,\vec{x}_i)$, but each such successor $(\loc',\vec{x}')$ uniquely 
%determines a transition $(\loc_i,\loc')$ ).
%%That is, if $\ell_i$ is angelic (resp., demonic) and $c_0c_1\cdots c_i$ is the
%%sequence of configurations observed so far,
%%then $\tau$ equals %%the distribution
%%$\sigma(c_0c_1\cdots c_i)$ (resp., $\pi(c_0c_1\cdots c_i)$).
%
%
%\item
%If $\ell_i$ is probabilistic, then $\tau$ is chosen randomly according to the
%distribution $\probdist_{\ell_i}$.
%\item
%If $\ell_i$ is deterministic or assignment location, then by the definition of 
%a pCFG there is exactly
%one enabled transition outgoing from $\ell_i$, and this transition is chosen as
%$\tau$.
%\end{compactitem}
%\item
%Once $\tau$ is chosen as above, we put $\loc_{i+1}=\loc'$. Next, if $\loc_i$ 
%is 
%not an assignment location, we put $\vec{x}_{i+1}=\vec{x}_{i}$. Otherwise 
%$\vec{x}_{i+1}=\vec{x}_{i}(j\leftarrow a)$, where $a$ chosen as follows:
%\begin{compactitem}
%\item If $u$ is a function $u\colon
%\Rset^{|\pvars|}\rightarrow \Rset$, then $a=f(\vec{x}_{i})$.
%\item If $\up$ is a distribution $d$, then $a$ 
%is sampled from $d$.
%\item If $\up$ is a set, then $a$ is sampled from a 
%distribution 
%$\sigmaa((\loc_0,\vec{x}_0)(\loc_1,\vec{x}_1)\cdots(\loc_i,\vec{x}_i))$.
%\end{compactitem}
%\end{compactitem}

The above intuitive explanation can be formalized by showing that
each pCFG $\pCFG$ together with a scheduler $\sigma$ and initial valuation 
$\vecinit\in \vecinitset$ uniquely determine a 
certain 
probabilistic 
space $(\OmegaRun,\natfilt,\probm^{\sigma}_{\vecinit})$ in which $\OmegaRun$ 
is a set of 
all 
runs in $\pCFG$, and a stochastic process 
$\pCFG^{\sigma}=\{\cfg{\sigma}{i}\}_{i=0}^{\infty}$ in this space 
such 
that for each run $\run\in \OmegaRun$ we have that $\cfg{\sigma}{i}(\run)$ is 
the 
$i$-th configuration on $\run$ (i.e., $\cfg{\sigma}{i}$ is a random vector 
$(\lr{\sigma}{i},\vr{\sigma}{i})$ with  $\lr{\sigma}{i}$ taking 
values in $\locs$ and $\vr{\sigma}{i}$ being a random vector of dimension 
$|\pvars|$ consisting of real-valued random variables). The sigma-algebra 
$\natfilt$ is the smallest (w.r.t. inclusion) sigma-algebra under which all 
the functions $\cfg{\sigma}{i}$, for all $i\geq 0$, 
are $\natfilt$-measurable (i.e., for each $\cfg{\sigma}{i}$ and each measurable 
set of configurations $\confset\in\mathcal{F}_{\Conf}$ it holds 
$\{\run\mid\cfg{\sigma}{i}(\run)\in \confset\}\in \natfilt$). Equivalently, 
$\natfilt$ can be defined as a sigma algebra generated by all set of runs of 
the form $F\times \Conf^{\infty}$, where $F\in \mathcal{H}$ is a measurable set 
of finite paths. The 
probability 
measure 
$\probm^{\sigma}_{\vecinit}$ is such that for each $i$, the distribution of 
$\cfg{\sigma}{i}$ reflects the aforementioned way in which runs are randomly 
generated. The formal construction 
of $\natfilt$ and $\probm^{\sigma}_{\vecinit}$ proceeds via the standard 
\emph{cylinder 
construction}~\cite[Theorem 2.7.2]{Ash:book} and is
somewhat 
technical, hence we omit it. 
We denote by $\E^\sigma_{\vecinit}$ the expectation operator in probability 
space 
$(\OmegaRun,\natfilt,\probm^{\sigma}_{\vecinit})$.
 
%We point out that the 
%construction produces pCFGs with a property that only transitions outgoing 
%from 
%a deterministic state can update program variables. All other transitions are 
%assumed to be of the form $(\ell,1,\id_1,\ell')$ for some locations 
%$\ell,\ell'$, where $\id_1(\vec{x})=\vec{x}[1]$ for all $\vec{x}$. We use this 
%to simplify notation.
%An illustration of a pCFG is given in Figure~\ref{fig:invariant-running}.

%and instead describe it informally by describing 
%the evolution of the stochastic process 
%$\pCFG^{\sigma}=(\cfg{\sigma}{i})_{i=0}^{\infty}$:
%%The evolution of 
%%$\pCFG^{\sigma}$
%%can be intuitively described as follows: 
%We have that $\lr{\sigma}{0}$ is the initial 
%location $\loc_0$, and $\vr{\sigma}{0}=\vec{x}_0$, i.e. 
%$\cfg{\sigma}{0}=(\loc_0,\vec{x}_0)$ with probability 1. Now assume that $i$ 
%%steps have elapsed, i.e. the vectors 
%%%$\cfg{\sigma}{0},\cfg{\sigma}{1},\dots,\cfg{\sigma}{i}$ are known. Then
%%\PN{continue from here}
%%the behaviour of $\mathcal{G}$ 
%%under angelic scheduler $\sigma$ and demonic
%%scheduler $\pi$ can then be intuitively described as follows: 
%%%The process starts in
%%the initial configuration $(\ell_0,\vec{x}_0)$. In every step $i$, assuming 
%%the
%%current configuration to be $(\ell_i,\vec{x}_i)$ the following happens:
%%%\PN{Continue from here}
%


%In this way, the players and random choices eventually produce a random run in
%$\mathcal{G}$. The above intuitive explanation can be formalized by showing 
%that
%the schedulers $\sigma$ and $\pi$ induce a unique probability measure
%$\probm^{\sigma,\pi}$ over a suitable $\sigma$-algebra having runs in
%$\mathcal{G}$ as a sample space. If $\mathcal{G}$ does not have any
%angelic/demonic locations, there is only one angelic/demonic scheduler (an 
%empty
%function) that we typically omit from the notation, i.e. if there are no 
%angelic
%locations we write only $\probm^{\pi}$ etc.
%%%The formal construction of this probability space is performed
%%in~\cite{appendix}.
%%%{\bf KRISH: DO WE WANT THE FORMAL CONSTRUCTION. IT IS FINE TO OMIT.}


\vspace{-1em}
\subsection{Almost-Sure and Positive Termination}
\vspace{-0.5em}
%Termination is the basic liveness property of \PP{}s. 

\smallskip\noindent{\em Termination and termination time.}
In the following, consider a \PP{} $P$ and its associated pCFG $\pCFG_P$. This 
pCFG has a special location  $\locterm$ corresponding to the value of 
the program counter after 
executing $P$.
We say that a run 
\emph{terminates} if it reaches a 
configuration whose first component is
$\loc_{P}^{\lout}$.
%
We define a random variable $\ttime$
such that for each run $\run$ the value $\ttime(\run)$ represents 
the first 
point in time when 
the current location is $\loc_P^{\lout}$. If a run $\run$ does 
\emph{not} 
terminate, then 
$\ttime(\run)=\infty$. We call $\ttime$ the 
\emph{termination time} of $\program$. 
%In particular, if $\confset$ is the set 
%of all configurations $(\loc,\vec{x})$ such that $\loc=\loc^\lout_P$ (the 
%terminal location of $\pCFG_P$), then $\treach{\confset}$ is 
%called a \emph{termination time}, as it returns the number of steps after 
%which 
%$\run$ terminates. Since termination time is an important concept on its own, 
%we use a special notation $\ttime$ for it.
%\begin{example}
%Consider the program $P$ such that \hspace{-0.25cm}\newsavebox{\figa}
%\lstset{language=affprob}
%\lstset{tabsize=1}
%\begin{lrbox}{\figa}
%\begin{lstlisting}[mathescape]
%$P=$x:=2;y:=1
%\end{lstlisting}
%\end{lrbox}
%\usebox{\figa}. The associated pCFG has three locations: initial location 
%$\loc_{P}^{\lin}$, terminal location $\loc_{P}^{\lout}$, and one 
%``intermediate'' location, say $\loc$. In the pCFG consider a run 
%$\run=(\loc_{P}^{\lin},(0,0))(\loc,(2,0))(\loc_{P}^{\lout},(2,1))(\loc_{P}^{\lout},(2,1))\cdots$.
% Then $\ttime(\run)=2$. If we denote by $C$ the set of configurations 
% $\{(\loc',(x,y))\mid \loc' \in\{\loc_{P}^{\lin},\loc_{P}^{\lout},\loc\} \text{ 
% and } x\geq 2\}$, then $\treach{C}(\run)=1$.
%\end{example}
%Since a probabilistic program may exhibit more than one run, we are interested 
%in probabilities of runs that terminate or reach some set of configurations. 
We consider the following fundamental computational problems regarding 
termination:

\begin{compactenum}
\item \emph{Almost-sure termination:} A probabilistic program $P$ is 
almost-surely (a.s.) 
terminating if under each scheduler $\sigma$ and for each initial valuation 
$\vecinit\in\vecinitset$ it holds that 
$\probm^{\sigma}_{\vecinit}(\{\run\mid \run \text{ terminates}\}) = 1$, or 
equivalently, 
if for each $\sigma$ it holds $\probm^{\sigma}(\ttime<\infty)=1$. In 
almost-sure termination question for $P$ we aim to prove that $P$ 
is 
almost-surely terminating.
\item \emph{Positive termination:} A probabilistic program $P$ is 
positively
terminating if under each scheduler $\sigma$ and for each initial valuation 
$\vecinit\in\vecinitset$ it holds that 
$\E^{\sigma}_{\vecinit}(\{\ttime\})<  \infty$. In 
positive termination question for $P$ we aim to prove that $P$ 
is 
positively terminating. Note that each positively terminating program is also 
a.s. terminating, but the converse does not hold.
\end{compactenum}

%We also define corresponding questions for the more general reachability 
%concept. 
% 
%\begin{compactenum}
%\item \emph{Almost-sure reachability:} For a set $C$ of configurations of a
%probabilistic program $P$, prove (if possible) that under each scheduler 
%$\sigma$ it holds that
%$\probm^{\sigma}(\treach{C}<\infty)=1$.
%\item \emph{Positive reachability:} For a set $C$ of configurations of 
%a probabilistic program $P$, prove (if possible) that under each scheduler 
%$\sigma$ it holds that
%$\E^{\sigma}(\treach{C})<\infty$.
%\end{compactenum}
%
%Since termination is a special case of reachability, each solution to the 
%almost-sure or probabilistic reachability questions provides solution for the 
%corresponding termination questions.
%\begin{example}\label{ex:illustrate}
%We now illustrate step by step how the SGS of Example~\ref{ex:sgs} corresponds
%to
%the program of Example~\ref{ex:prog}.
%We first consider the statements $Q_1$ and $Q_2$ (Figure~\ref{fig:Q1Q2}), and
%show the
%corresponding SGSs in Figure~\ref{fig:Q1Q2:SGS}.
%Then consider the statement block $Q_3$ which is a probabilistic choice between
%$Q_1$ and $Q_2$  (Figure~\ref{fig:Q3}).
%The corresponding SGS  (Figure~\ref{fig:Q3:SGS}) is obtained from the previous
%two
%SGSs as follows: we consider a probabilistic start location where there is a
%probabilistic
%branch to the start locations of the SGSs of $Q_1$ and $Q_2$, and the SGS ends
%in a location with only self-loop.
%Finally, we consider the whole program as $Q_4$ (Figure~\ref{fig:Q4}),
%and the corresponding SGS in  (Figure~\ref{fig:Q4:SGS}).
%The SGS is obtained from SGS for $Q_3$, with the self-loop replaced by a
%transition
%back to the probabilistic location (with guard $x\geq 0$), and an edge to the
%final location
%(with guard $x<0$).
%The start location of the whole program is a new location, with transition
%labeled
%$x:=0$, to the start of the while loop location.
%We label the locations in Figure~\ref{fig:Q4:SGS} to refer to them later.
%\lstset{language=affprob}
%\lstset{tabsize=3}
%\newsavebox{\figa}
%\begin{lrbox}{\figa}
%\begin{lstlisting}[mathescape]
%$Q_1$:	if angel then $x:=x+1$ else $x:=x-1$ fi	
%$Q_2$:	if demon then $x:=x+1$ else $x:=x-1$ fi
%\end{lstlisting}
%\end{lrbox}
%\begin{figure}[h]
%\centering
%\usebox{\figa}
%\caption{Programs $Q_1$ and $Q_2$}
%\label{fig:Q1Q2}
%\end{figure}
%
%\begin{figure}[h]
%\centering
%\begin{tikzpicture}[x=1.8cm]
%\node[det] (fin1) at (0,-1.5)  {};
%\node[ang] (angel) at (0,0) {};
%\node[det] (fin2) at (2.3,-1.5)  {};
%\node[dem] (demon) at (2.3,0)  {};
%\node[det] (aif) at (-1,0) {};
%\node[det] (aelse) at (1,0) {};
%\node[det] (dif) at (1.3,-1.5) {};
%\node[det] (delse) at (3.3,-1.5) {};
%
%\draw[tran] (angel.155) -- (aif);
%\draw[tran] (angel.25) -- (aelse);
%\draw[tran] (demon) -- (dif);
%\draw[tran] (demon) -- (delse);
%
%\path (fin1) edge [tran, loop left] (fin1);
%\path (fin2) edge [tran, loop below] (fin2);
%\draw[tran] (dif) -- node[auto,swap] {x:=x+1} (fin2);
%\draw[tran] (delse) -- node[auto] {x:=x-1} (fin2);
%\draw[tran] (aif) -- node[auto, swap] {x:=x+1} (fin1);
%%\draw[tran] (demon) to node[auto] {x:=x-1} (fin2);
%\draw[tran] (aelse) to node[auto] {x:=x-1} (fin1);
%\end{tikzpicture}
%\caption{SGSs for $Q_1$ (left) and $Q_2$ (right)}
%\label{fig:Q1Q2:SGS}
%\end{figure}
%
%\newsavebox{\figb}
%\begin{lrbox}{\figb}
%\begin{lstlisting}[mathescape]
%$Q_3$:	if prob(0.6) then $Q_1$ else $Q_2$ fi
%\end{lstlisting}
%\end{lrbox}
%\begin{figure}[h]
%\centering
%\usebox{\figb}
%\caption{Program $Q_3$}
%\label{fig:Q3}
%\end{figure}
%\begin{figure}[h]
%\centering
%\begin{tikzpicture}[x = 1.8cm]
%\node[det] (while) at (1.5,-1.5)  {};
%%%\node[det] (fin) at (0,-3) {};
%\node[ran] (prob) at (3.7,-1.5) {};
%\node[ang] (angel) at (3,0) {};
%\node[dem] at (3,-3) (demon) {};
%\node[det] (aif) at (2,-0.075) {};
%\node[det] (aelse) at (3,-0.8) {};
%\node[det] (dif) at (2,-3) {};
%\node[det] (delse) at (3,-2.2) {};
%
%\draw[tran] (angel) -- (aif);
%\draw[tran] (angel) -- (aelse);
%\draw[tran] (demon) -- (dif);
%\draw[tran] (demon) -- (delse);
%
%\path (while) edge [tran, loop left] (while);
%\draw[tran] (prob) -- node[font=\scriptsize,draw, fill=white, 
%rectangle,pos=0.3,
%inner sep = 1pt] {$\frac{6}{10}$} (prob|-angel) -- (angel);
%\draw[tran] (prob) -- node[font=\scriptsize,draw, fill=white, 
%rectangle,pos=0.3,
%inner sep = 1pt] {$\frac{4}{10}$} (prob|-demon) --(demon);
%\draw[tran] (dif) --  (demon-|while) -- node[auto, pos=0.2] {x:=x+1} (while);
%\draw[tran] (aif) --  (angel-|while) -- node[auto, swap, pos=0.2] {x:=x+1}
%(while);
%\draw[tran] (delse) -- node[auto] {x:=x-1} (delse-|while.305) --  (while.-55);
%\draw[tran] (aelse) -- node[auto, swap] {x:=x-1} (aelse-|while.55) -- 
%(while.55);
%\end{tikzpicture}
%\caption{SGS of $Q_3$}
%\label{fig:Q3:SGS}
%\end{figure}
%\newsavebox{\figc}
%\begin{lrbox}{\figc}
%\begin{lstlisting}[mathescape]
%$Q_4$:	$x:=0$; while ($x\ge 0$) do $Q_3$ od
%\end{lstlisting}
%\end{lrbox}
%\begin{figure}[h]
%\centering
%\usebox{\figc}
%\caption{Program $Q_4$}
%\label{fig:Q4}
%\end{figure}
%\begin{figure}[h]
%\centering
%\begin{tikzpicture}[x = 1.8cm]
%%\node[det] (det1) at (0,0) {$\loc_0$};
%%\node[det] (while) at (1.5,-1.5)  {$\loc_1$};
%%\node[det] (fin) at (0,-3) {$\loc_5$};
%%\node[ran] (prob) at (3,-1.5) {$\loc_2$};
%%\node[ang] (angel) at (3,0) {$\loc_3$};
%%\node[dem] (demon) at (3,-3)  {$\loc_4$};
%%
%%\draw[tran] (det1) to node[auto, swap] {x:=0} (while);
%%\draw[tran] (while) to node[font=\scriptsize,draw, fill=white,
%%rectangle,pos=0.3] {$x<0$} (fin);
%%\draw[tran, loop, looseness = 5, in =-65, out = -115] (fin) to (fin);
%%\draw[tran] (while) to node[font=\scriptsize,draw, fill=white,
%%rectangle,pos=0.3] {$x\geq 0$} (prob);
%%\draw[tran] (prob) to node[font=\scriptsize,draw, fill=white,
%%rectangle,pos=0.3, inner sep = 1pt] {$\frac{6}{10}$} (angel);
%%\draw[tran] (prob) to node[font=\scriptsize,draw, fill=white,
%%rectangle,pos=0.3, inner sep = 1pt] {$\frac{4}{10}$} (demon);
%%\draw[tran] (demon) -- node[auto] {x:=x+1} (demon-|while) -- (while);
%%\draw[tran] (angel) -- node[auto, swap] {x:=x+1} (angel-|while) -- (while);
%%\draw[tran] (demon) to node[auto] {x:=x-1} (while);
%%\draw[tran] (angel) to node[auto, swap] {x:=x-1} (while);
%
%\node[det] (while) at (1.5,-1.5)  {$\loc_1$};
%%%\node[det] (fin) at (0,-3) {};
%\node[ran] (prob) at (3.7,-1.5) {$\loc_2$};
%\node[ang] (angel) at (3,0) {$\loc_3$};
%\node[dem] at (3,-3) (demon) {$\loc_4$};
%\node[det] (aif) at (2,-0.075) {$\loc_5$};
%\node[det] (aelse) at (3,-0.8) {$\loc_6$};
%\node[det] (dif) at (2,-3) {$\loc_7$};
%\node[det] (delse) at (3,-2.2) {$\loc_8$};
%\node[det] (det1) at (0,0) {$\loc_0$};
%%\node[det] (while) at (1.5,-1.5)  {};
%\node[det] (fin) at (0,-3) {$\loc_9$};
%%\node[ran] (prob) at (3,-1.5) {};
%%\node[ang] (angel) at (3,0) {};
%%\node[dem] at (3,-3) (demon) {};
%%
%\draw[tran] (det1) to node[auto, swap] {x:=0} (while);
%\draw[tran] (while) to node[font=\scriptsize,draw, fill=white,
%rectangle,pos=0.4] {$x<0$} (fin);
%\draw[tran, loop, looseness = 5, in =-65, out = -115] (fin) to (fin);
%\draw[tran] (while) to node[font=\scriptsize,draw, fill=white,
%rectangle,pos=0.3] {$x\geq 0$} (prob);
%%\draw[tran] (prob) to node[font=\scriptsize,draw, fill=white,
%%rectangle,pos=0.3, inner sep = 1pt] {$\frac{6}{10}$} (angel);
%%\draw[tran] (prob) to node[font=\scriptsize,draw, fill=white,
%%rectangle,pos=0.3, inner sep = 1pt] {$\frac{4}{10}$} (demon);
%%\draw[tran] (demon) -- node[auto] {x:=x+1} (demon-|while) -- (while);
%%\draw[tran] (angel) -- node[auto, swap] {x:=x+1} (angel-|while) -- (while);
%%\draw[tran] (demon) to node[auto] {x:=x-1} (while);
%%\draw[tran] (angel) to node[auto, swap] {x:=x-1} (while);
%
%
%\draw[tran] (angel) -- (aif);
%\draw[tran] (angel) -- (aelse);
%\draw[tran] (demon) -- (dif);
%\draw[tran] (demon) -- (delse);
%
%\draw[tran] (prob) -- node[font=\scriptsize,draw, fill=white, 
%rectangle,pos=0.3,
%inner sep = 1pt] {$\frac{6}{10}$} (prob|-angel) -- (angel);
%\draw[tran] (prob) -- node[font=\scriptsize,draw, fill=white, 
%rectangle,pos=0.3,
%inner sep = 1pt] {$\frac{4}{10}$} (prob|-demon) --(demon);
%\draw[tran] (dif) --  (demon-|while) -- node[auto, pos=0.2] {x:=x+1} (while);
%\draw[tran] (aif) --  (angel-|while) -- node[auto, swap, pos=0.2] {x:=x+1}
%(while);
%\draw[tran] (delse) -- node[auto] {x:=x-1} (delse-|while.305) --  (while.-55);
%\draw[tran] (aelse) -- node[auto, swap] {x:=x-1} (aelse-|while.55) -- 
%(while.55);
%\end{tikzpicture}
%\caption{SGS of $Q_4$}
%\label{fig:Q4:SGS}
%\end{figure}
%\end{example}

%\subsection{Qualitative and Quantitative Termination Questions}
%We consider the most basic notion of liveness, namely {\em termination},
%for probabilistic programs, and present the relevant {\em qualitative} and
%{\em quantitative} questions.
%
%
%
%\paragraph*{Qualitative question.}
%We consider the two basic qualitative questions, namely, almost-sure 
%termination
%(i.e., termination with probability~$1$) and finite expected termination time.
%We formally define them below.
%
%
%Given a program $P$, let $\mathcal{G}_P$ be the associated SGS.
%A run $\rho$ is \emph{terminating} if it reaches a configuration in which the
%location is $\ell^{\lout}_{P}$.
%Consider the random variable $T$ which to every run $\rho$ in $\mathcal{G}_P$
%assigns the first point in time in which a configuration with the location
%$\ell^{\lout}_{P}$ is encountered,
%and if the run never reaches such a configuration, then the value assigned is
%$\infty$.
%
%
%\begin{definition}[Qualitative termination questions]
%Given a program $P$ and its associated normalized SGS $\mathcal{G}_P$, we
%consider the following
%two questions:
%\begin{compactenum}
%\item {\em Almost-Sure Termination.} The program is {\em almost-surely (a.s.)}
%terminating if
%there exists an angelic scheduler (called {\em a.s terminating}) $\sigma$ such
%that for all demonic
%schedulers $\pi$ we have
%$\probm^{\sigma,\pi}\left( \{\rho\mid\rho \text{ is terminating}\,\}\right) =
%1;$ or equivalently,
%$\probm^{\sigma,\pi}(T<\infty)=1$.
%
%\item {\em Finite Termination.}
%The program $P$ is \emph{finitely terminating} (aka positively almost-sure
%terminating) if there
%exists an angelic scheduler $\sigma$ (called {\em finitely terminating})
%such that for all demonic schedulers $\pi$ it holds that
%$\expv^{\sigma,\pi}[T]<\infty.$
%%%A scheduler $\sigma$ with this property is said to be \emph{positively
%%terminating}.
%\end{compactenum}
%
%\end{definition}
%
%Note that for all angelic schedulers $\sigma$ and demonic schedulers $\pi$ we
%have $\expv^{\sigma,\pi}[T]<\infty$ implies $\probm^{\sigma,\pi}(T<\infty)=1$,
%however, the converse does not hold in general.
%In other words, finitely terminating implies a.s. terminating, but a.s.
%termination does not imply finitely termination.
%
%\begin{definition}[Quantitative termination questions]
%\label{def:quanttq}
%Given a program $P$ and its associated normalized SGS $\mathcal{G}_P$, we
%consider the following
%notions:
%\begin{compactenum}
%\item {\em Expected Termination Time.} The {\em expected termination} time of
%$P$ is
%$\Eval(P) = \inf_{\sigma}\sup_{\pi}\expv^{\sigma,\pi}[T]. $
%
%\item {\em Concentration bound.} A bound $B$ is a {\em concentration bound} if
%there exists two positive constants $c_1$ and $c_2$ such that for all $x\geq 
%B$,
%we have
%$\Thr(P,x) \leq c_1 \cdot \exp(-c_2\cdot x)$, where $\Thr(P,x)=\inf_{\sigma}
%\sup_{\pi} \probm^{\sigma,\pi}(T > x)$ (i.e., the probability that the
%termination time exceeds $x \geq B$ decreases exponentially in $x$).
%\end{compactenum}
%\end{definition}
%
%Note that we assume that an SGS $\mathcal{G}_P$ for a program $P$ is already
%given in a normalized form, as our algorithms assume that all guards in
%$\mathcal{G}_P$ are in DNF.
%%To separate the complexity of normalizing an SGS from the complexity of 
%%solving
%%our qualitative and quantitative question we assume
%In general, converting an SGS into a normalized SGS incurs an exponential
%blow-up as this is the worst-case blowup when converting a formula into DNF.
%However, we note that for programs $\mathcal{P}$ that contain only \emph{simple
%guards}, i.e. guards that are either conjunctions or disjunctions of linear
%constraints, a normalized game $\mathcal{G}_P$ can be easily constructed in
%polynomial time using de Morgan laws. In particular, we stress that all our
%hardness results hold already for programs with simple guards, so they do not
%rely on the requirement that $\mathcal{G}_P$ must be normalized.




\lstset{language=affprob}
\lstset{tabsize=3}
\newsavebox{\invrun}
\begin{lrbox}{\invrun}
\begin{lstlisting}[mathescape]
while $x\geq 0$ and $y\geq 0$ do
	if * then
		if prob(0.5) then 
			$x:=x-2$ 
		else skip 
		fi
	else 
		$x:=2x$;
		$y:=y-1$
	fi
od
\end{lstlisting}
\end{lrbox}
\begin{figure}[t]
	\begin{subfigure}{0.45\textwidth}
\centering
\usebox{\invrun}
%\caption{}
\end{subfigure}
\begin{subfigure}{0.45\textwidth}
	\centering
\begin{tikzpicture}
%\node[det] (det1) at (0,0) {$\loc_0$};
%\node[det] (while) at (1.5,-1.5)  {$\loc_1$};
%\node[det] (fin) at (0,-3) {$\loc_5$};
%\node[ran] (prob) at (3,-1.5) {$\loc_2$};
%\node[ang] (angel) at (3,0) {$\loc_3$};
%\node[dem] (demon) at (3,-3)  {$\loc_4$};
%
%\draw[tran] (det1) to node[auto, swap] {x:=0} (while);
%\draw[tran] (while) to node[font=\scriptsize,draw, fill=white, 
%rectangle,pos=0.3] {$x<0$} (fin);
%\draw[tran, loop, looseness = 5, in =-65, out = -115] (fin) to (fin);
%\draw[tran] (while) to node[font=\scriptsize,draw, fill=white, 
%rectangle,pos=0.3] {$x\geq 0$} (prob);
%\draw[tran] (prob) to node[font=\scriptsize,draw, fill=white, 
%rectangle,pos=0.3, inner sep = 1pt] {$\frac{6}{10}$} (angel);
%\draw[tran] (prob) to node[font=\scriptsize,draw, fill=white, 
%rectangle,pos=0.3, inner sep = 1pt] {$\frac{4}{10}$} (demon);
%\draw[tran] (demon) -- node[auto] {x:=x+1} (demon-|while) -- (while);
%\draw[tran] (angel) -- node[auto, swap] {x:=x+1} (angel-|while) -- (while);
%\draw[tran] (demon) to node[auto] {x:=x-1} (while);
%\draw[tran] (angel) to node[auto, swap] {x:=x-1} (while);

\node[det] (while) at (0,0)  {$\loc_0$};
%\node[det] (while) at (0,0)  {$\loc_0$};
%%\node[det] (fin) at (0,-3) {};
\node[dem] (demon) at (2,0) {$\loc_1$};
%\node[ang] (angel) at (3,0) {$\loc_3$};
%\node[dem] at (3,-3) (demon) {$\loc_4$};
%\node[det] (aif) at (2,-0.075) {$\loc_5$};
%\node[det] (aelse) at (3,-0.8) {$\loc_6$};
%\node[det] (dif) at (2,-3) {$\loc_7$};
%\node[det] (delse) at (3,-2.2) {$\loc_8$};
%\node[det] (det1) at (0,0) {$\loc_0$};
%\node[det] (while) at (1.5,-1.5)  {};
\node[det] (br1) at (3.5,0)  {$\loc_2$};
\node[det] (br11) at (2,1)	{$\loc_6$};
\node[ran] (br2) at (2,-1.5)  {$\loc_3$};
\node[det] (pr1) at (3.5,-1.5)  {$\loc_4$};
\node[det] (pr2) at (3.5,-3)  {$\loc_5$};
\node[det] (fin) at (0,-1.5) {$\loc_7$};
%\node[ran] (prob) at (3,-1.5) {};
%\node[ang] (angel) at (3,0) {};
%\node[dem] at (3,-3) (demon) {};
%
%%\draw[tran] (det1) to node[auto, swap] {x:=0} (while);
\draw[tran] (while) to node[font=\scriptsize,draw, fill=white, 
rectangle,pos=0.5] {$x<0 \vee y<0$} (fin);
\draw[tran, loop, looseness = 5, in =-65, out = -115] (fin) to (fin);
\draw[tran] (while) to node[font=\scriptsize,draw, fill=white, 
rectangle,pos=0.5, text width=0.8cm, text centered] {$x\geq0$ \\$\wedge$ 
\\$y\geq0$} (demon);
\draw[tran] (demon) to (br1);
\draw[tran] (demon) to (br2);
\draw[tran] (br2) to node[font=\scriptsize,draw, fill=white, 
rectangle,pos=0.5, inner sep = 1pt] {$\frac{1}{2}$} (pr1);
\draw[tran] (br2) to node[font=\scriptsize,draw, fill=white, 
rectangle,pos=0.5, inner sep = 1pt] {$\frac{1}{2}$} (pr2);
\draw[tran, rounded corners] (br1) -- (3.5,1) -- node[font=\scriptsize, 
label={[font=\scriptsize, yshift=-0.5cm] {$x:=2x$}},swap] {}  
(br11);
\draw[tran, rounded corners] (br11) -- node[font=\scriptsize, 
label={[font=\scriptsize, yshift=-0.55cm] {$y:=y-1$}}] {} (while.70|-br11) -- 
(while.70);
\draw[tran, rounded corners] (pr1) -- (3.9,-1.5) -- (3.9,1.5) -- 
(while|-3.9,1.5) -- 
(while);
\draw[tran, rounded corners] (pr2) -- (4.1,-3) -- node[font=\scriptsize, 
label={[font=\scriptsize,xshift=0.6cm] {$x:=x-2$}}] {} (4.1,1.7) -- 
(while.110|-4.1,1.7) -- 
(while.110);
%\draw[tran] (demon) -- node[auto] {x:=x+1} (demon-|while) -- (while);
%\draw[tran] (angel) -- node[auto, swap] {x:=x+1} (angel-|while) -- (while);
%\draw[tran] (demon) to node[auto] {x:=x-1} (while);
%\draw[tran] (angel) to node[auto, swap] {x:=x-1} (while);


%\draw[tran] (angel) -- (aif);
%\draw[tran] (angel) -- (aelse);
%\draw[tran] (demon) -- (dif);
%\draw[tran] (demon) -- (delse);

%\node (dum1) at (0,0.8) {};
%\node (dum2) at (0,-0.8) {};

%\draw[tran] (prob) -- node[font=\scriptsize,draw, fill=white, 
%rectangle,pos=0.5, inner sep = 1pt] {$\frac{3}{4}$} (prob|-dum1) -- node[auto] 
%{x:=x-1}
%(while|-dum1)--(while);
%\draw[tran] (prob) -- node[font=\scriptsize,draw, fill=white, 
%rectangle,pos=0.5, inner sep = 1pt] {$\frac{1}{4}$} (prob|-dum2) 
%-- node[auto,swap] {x:=x+1} (while|-dum2)--(while);
%\draw[tran] (dif) --  (demon-|while) -- node[auto, pos=0.2] {x:=x+1} (while);
%\draw[tran] (aif) --  (angel-|while) -- node[auto, swap, pos=0.2] {x:=x+1} 
%(while);
%\draw[tran] (delse) -- node[auto] {x:=x-1} (delse-|while.305) --  (while.-55);
%\draw[tran] (aelse) -- node[auto, swap] {x:=x-1} (aelse-|while.55) --  
%(while.55);
\end{tikzpicture}
%\caption{}
\end{subfigure}
%\vspace{-3em}
\caption{An example \APP{} and its associated 
pCFG. Probabilistic locations are depicted by circles, with probabilities given 
on outgoing 
transitions, demonic locations are denoted by diamonds. Transitions are 
labelled by their effects. Location $\loc_0$ is 
initial and $\loc_7$ is terminal.}
\label{fig:invariant-running}
\end{figure}

