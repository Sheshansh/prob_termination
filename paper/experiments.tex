
\section{Experimental Results}\label{sec:experiments}
We have implemented our algorithm (in C++) and present two sets of experimental results.
For all the experimental results we use Aspic~\cite{} for invariant generation, 
and our algorithm requires linear-programming solution for which we use CPlex~\cite{}.
Our experimental results were obtained on [SPEC OF COMPUTER].


\smallskip\noindent{\em Abstraction of real-world programs.}
We consider benchmarks considered for real-world non-probabilistic programs 
in~\cite{ADFG10:lexicographic}.
Note that there are no abstraction tools available for probabilistic programs (to the
best of our knowledge). 
Hence we consider the abstract programs obtained from real-world benchmarks as 
considered in the benchmark suite of~\cite{ADFG10:lexicographic}.
Given these non-probabilistic programs we obtain probabilistic programs in two ways:
(a)~{\em probabilistic loops} where the existing while loops are made probabilistic 
by executing the statements with probability~1/2, and with remaining probabilities 
executing skip statements;
(b)~{\em probabilistic assignments} where the existing assignments are changed to 
probabilistic assignments with variables generated uniformly in range $[-1,1]$ 
(i.e., we consider a variable $r$ whose value is generated by probabilistic 
assignment uniformly in the range $[-1,1]$ and add the variable to the existing 
assignment).
We report our results on twentfy five benchmarks in Table~\ref{tab:exp1} (since we consider around 
fifty benchmark examples the results on the remaining ones are presented in Appendix, Section~\ref{sec:app_ex}).
We show the time taken by our approach, which is always less than $1/10$-th of second.
We show whether solution exists or not (i.e., whether linear lexicographic RSMs exist
or not), and if the solution exists we present the dimension of the lexicographic RSM
we obtain. In all cases the dimension is quite small (at most~3). 
We also show whether we enhance the program with probabilistic loops and probabilistic assignments.


\smallskip\noindent{\em Constructed large programs.} 
The programs obtained as abstractions of real-world programs in the benchmarks 
as mentioned above have between 10-100 lines of code. 
To test the how does our approach scale with larger codes we consider large
probabilistic programs generated as follows.
Given $n$ Boolean variables, we consider probabilistic while loops,
some nondeterministic conditional branches, and all possible $2^n$ if conditions
based on the Boolean variables. 
Hence given $n$ variables we have probabilistic programs of size $O(2^n)$, and 
we first ran an invariant generation tool, followed by our algorithm.
In all these examples lexicographic RSMs exist, and has dimension at most~3.
Even for programs with around 12K lines of codes the total time taken is around 
one hour, where the invariant generation (i.e., running Aspic) takes the maximum time, 
and our algorithm requires around two minutes.
The results are presented in Table~\ref{tab:exp2}.





% The main table which contains 25 entries

\begin{center}
\begin{table}[]
  \centering
   \begin{tabular}{c|c|c|c|c|c}
    
   {Benchmark} & {Time (s)} & {Solution} & {Dimension} & {Prob. loops} & {Prob. Assignments
} \\\hline
{alain} & {0.09} & {yes} & {2} & {yes} & {yes
} \\\hline
{catmouse} & {0.06} & {yes} & {2} & {yes} & {yes
} \\\hline
{counterex1a} & {0.08} & {no} & {} & {no} & {no
} \\\hline
{counterex1c} & {0.09} & {yes} & {3} & {yes} & {yes
} \\\hline
{easy1} & {0.07} & {yes} & {1} & {yes} & {yes
} \\\hline
{exmini} & {0.07} & {yes} & {2} & {yes} & {yes
} \\\hline
{insertsort} & {0.08} & {yes} & {3} & {yes} & {yes
} \\\hline
{ndecr} & {0.07} & {yes} & {2} & {yes} & {yes
} \\\hline
{perfect} & {0.09} & {yes} & {3} & {yes} & {yes
} \\\hline
{perffect2} & {0.1} & {yes} & {3} & {yes} & {no
} \\\hline
{real2} & {0.07} & {no} & {} & {no} & {no
} \\\hline
{realheapsort\_step2} & {0.07} & {yes} & {1} & {no} & {no
} \\\hline
{realshellsort} & {0.07} & {yes} & {1} & {no} & {no
} \\\hline
{serpent} & {0.08} & {yes} & {1} & {yes} & {yes
} \\\hline
{sipmabubble} & {0.08} & {yes} & {3} & {yes} & {yes
} \\\hline
{speedDis2} & {0.07} & {no} & {} & {no} & {no
} \\\hline
{speedFails2} & {0.06} & {yes} & {2} & {yes} & {no
} \\\hline
{speedNestedMultiple} & {0.08} & {yes} & {3} & {yes} & {yes
} \\\hline
{speedpldi2} & {0.07} & {yes} & {2} & {yes} & {yes
} \\\hline
{speedpldi4} & {0.07} & {yes} & {3} & {yes} & {yes
} \\\hline
{speedSimpleMultipleDep} & {0.07} & {no} & {} & {no} & {no
} \\\hline
{speedSingleSingle2} & {0.08} & {yes} & {2} & {yes} & {no
} \\\hline
{unperfect} & {0.08} & {yes} & {2} & {yes} & {no
} \\\hline
{wcet1} & {0.09} & {yes} & {2} & {yes} & {yes
} \\\hline
{while2} & {0.08} & {yes} & {3} & {yes} & {yes} \\\hline
    
\end{tabular}
\caption{Experimental results for benchmarks from~\cite{ADFG10:lexicographic} extended with probabilistic loops and/or probabilistic assignments.} \label{tab:exp1}
\end{table}
\end{center}

\begin{center}
\begin{table}[]
  \centering
   \begin{tabular}{c|c|c|c|c}

{Variables} & {LOC} & {Inv Time (s)} & {Our Time (s)} & {Total Time (s)} \\\hline
{2} & {20} & {0.050189} & {0.028366} & {0.078555} \\\hline
{3} & {32} & {0.060078} & {0.02359} & {0.083668} \\\hline
{4} & {56} & {0.074388} & {0.030035} & {0.104423} \\\hline
{5} & {104} & {0.131122} & {0.051545} & {0.182667} \\\hline
{6} & {200} & {0.354702} & {0.097943} & {0.452645} \\\hline
{7} & {392} & {1.30833} & {0.29947} & {1.6078} \\\hline
{8} & {776} & {7.55238} & {0.69566} & {8.24804} \\\hline
{9} & {1544} & {33.0638} & {2.4977} & {35.5615} \\\hline
{10} & {3080} & {164.088} & {8.763} & {172.851} \\\hline
{11} & {6152} & {817.914} & {35.37} & {853.284} \\\hline
{12} & {12296} & {4260.96} & {145.18} & {4406.14} \\\hline
\end{tabular}
\caption{Experimental results for synthetic examples.}\label{tab:exp2}
\end{table}
\end{center}
