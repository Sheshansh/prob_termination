Analyzing : aspic.fst with acceleration. 
2017, Jun 21,15:03:35 with aspic Version 3.4

 The graph loops structure  = [0; 2; 4; [3; 5; 7; 6]; 1]

 strategy=[(state_1,[],false); (state_3,[t_1_0],false);
           (state_5,[t_3_1__tsplit1,t_3_1__tsplit0],false);
           [(state_4,[t_8_0,t_7_0,t_3_0],true); (state_6,[t_4_0],false);
            (state_8,[t_6_1],false); (state_7,[t_6_0],false)];
           (state_2,[t_5_0,t_4_1__tsplit1,t_4_1__tsplit0],false)]
  Processing strategy [(state_1,[],false); (state_3,[t_1_0],false);
                       (state_5,[t_3_1__tsplit1,t_3_1__tsplit0],false);
                       [(state_4,[t_8_0,t_7_0,t_3_0],true);
                        (state_6,[t_4_0],false); (state_8,[t_6_1],false);
                        (state_7,[t_6_0],false)];
                       (state_2,[t_5_0,t_4_1__tsplit1,t_4_1__tsplit0],false)]

  ** processing vertex state_3 :
    the old polyhedron is  empty(3) 
    the incoming hedges are not meta ones 
    dealing with hedge t_1_0 (coming from loc state_1)
    we apply the transfo to the poly {$>=0,1>0} in the prec hedge
    contrib of hedge t_1_0 (coming from loc state_1) = {$>=0,1>0}
    the contributions from the preceeding nodes is  {$>=0,1>0} 
    nreach={$>=0,1>0}

  ** processing vertex state_5 :
    the old polyhedron is  empty(3) 
    the incoming hedges are not meta ones 
    dealing with hedge t_3_1__tsplit1 (coming from loc state_3)
    we apply the transfo to the poly {$>=0,1>0} in the prec hedge
    contrib of hedge t_3_1__tsplit1 (coming from loc state_3) = {$>=0,1>0,
                                                                 x<=y}
    dealing with hedge t_3_1__tsplit0 (coming from loc state_3)
    we apply the transfo to the poly {$>=0,1>0} in the prec hedge
    contrib of hedge t_3_1__tsplit0 (coming from loc state_3) = {$>=0,1>0,
                                                                 tx<0}
    the contributions from the preceeding nodes is  {1>0,$>=0} 
    nreach={1>0,$>=0}
  Processing strategy [(state_4,[t_8_0,t_7_0,t_3_0],true);
                       (state_6,[t_4_0],false); (state_8,[t_6_1],false);
                       (state_7,[t_6_0],false)]

  ** processing vertex state_4 with widening:
    the old polyhedron is  empty(3) 
    the incoming hedges are not meta ones 
    dealing with hedge t_3_0 (coming from loc state_3)
    we apply the transfo to the poly {$>=0,1>0} in the prec hedge
    contrib of hedge t_3_0 (coming from loc state_3) = {$>=0,1>0,x>y,tx>=0}
    the contributions from the preceeding nodes is  {$>=0,1>0,x>y,tx>=0} 
    nreach={$>=0,1>0,x>y,tx>=0}

  ** processing vertex state_6 :
    the old polyhedron is  empty(3) 
    the incoming hedges are not meta ones 
    dealing with hedge t_4_0 (coming from loc state_4)
    we apply the transfo to the poly {$>=0,1>0,x>y,tx>=0} in the prec hedge
    contrib of hedge t_4_0 (coming from loc state_4) = {$>=0,1>0,x>y,tx>=0}
    the contributions from the preceeding nodes is  {$>=0,1>0,x>y,tx>=0} 
    nreach={$>=0,1>0,x>y,tx>=0}

  ** processing vertex state_8 :
    the old polyhedron is  empty(3) 
    the incoming hedges are not meta ones 
    dealing with hedge t_6_1 (coming from loc state_6)
    we apply the transfo to the poly {$>=0,1>0,x>y,tx>=0} in the prec hedge
    contrib of hedge t_6_1 (coming from loc state_6) = {$>=0,1>0,x>y,tx>=0}
    the contributions from the preceeding nodes is  {$>=0,1>0,x>y,tx>=0} 
    nreach={$>=0,1>0,x>y,tx>=0}

  ** processing vertex state_7 :
    the old polyhedron is  empty(3) 
    the incoming hedges are not meta ones 
    dealing with hedge t_6_0 (coming from loc state_6)
    we apply the transfo to the poly {$>=0,1>0,x>y,tx>=0} in the prec hedge
    contrib of hedge t_6_0 (coming from loc state_6) = {$>=0,1>0,x>y,tx>=0}
    the contributions from the preceeding nodes is  {$>=0,1>0,x>y,tx>=0} 
    nreach={$>=0,1>0,x>y,tx>=0}

  ** processing vertex state_4 with widening:
    the old polyhedron is  {$>=0,1>0,x>y,tx>=0} 
    the incoming hedges are not meta ones 
    dealing with hedge t_8_0 (coming from loc state_8)
    we apply the transfo to the poly {$>=0,1>0,x>y,tx>=0} in the prec hedge
    contrib of hedge t_8_0 (coming from loc state_8) = constraints not available(3)
    dealing with hedge t_7_0 (coming from loc state_7)
    we apply the transfo to the poly {$>=0,1>0,x>y,tx>=0} in the prec hedge
    contrib of hedge t_7_0 (coming from loc state_7) = constraints not available(3)
    the contributions from the preceeding nodes is  {tx>=0,tx+x+1>y,$>=0,1>0} 
    nreach={tx>=0,tx+x+1>y,$>=0,1>0}
     widen part :
    widening {$>=0,1>0,x>y,tx>=0} by {tx>=0,tx+x+1>y,$>=0,1>0} ? 
   nb of hedges = 3
        acceleration (or smt) and new control path  : do not widen

  ** processing vertex state_6 :
    the old polyhedron is  {$>=0,1>0,x>y,tx>=0} 
    the incoming hedges are not meta ones 
    dealing with hedge t_4_0 (coming from loc state_4)
    we apply the transfo to the poly {tx>=0,tx+x+1>y,$>=0,1>0} in the prec hedge
    contrib of hedge t_4_0 (coming from loc state_4) = {$>=0,1>0,tx>=0,x>=y}
    the contributions from the preceeding nodes is  {$>=0,1>0,tx>=0,x>=y} 
    nreach={1>0,tx>=0,$>=0,x>=y}
      do not widen

  ** processing vertex state_8 :
    the old polyhedron is  {$>=0,1>0,x>y,tx>=0} 
    the incoming hedges are not meta ones 
    dealing with hedge t_6_1 (coming from loc state_6)
    we apply the transfo to the poly {1>0,tx>=0,$>=0,x>=y} in the prec hedge
    contrib of hedge t_6_1 (coming from loc state_6) = {1>0,tx>=0,$>=0,x>=y}
    the contributions from the preceeding nodes is  {1>0,tx>=0,$>=0,x>=y} 
    nreach={1>0,tx>=0,$>=0,x>=y}
      do not widen

  ** processing vertex state_7 :
    the old polyhedron is  {$>=0,1>0,x>y,tx>=0} 
    the incoming hedges are not meta ones 
    dealing with hedge t_6_0 (coming from loc state_6)
    we apply the transfo to the poly {1>0,tx>=0,$>=0,x>=y} in the prec hedge
    contrib of hedge t_6_0 (coming from loc state_6) = {1>0,tx>=0,$>=0,x>=y}
    the contributions from the preceeding nodes is  {1>0,tx>=0,$>=0,x>=y} 
    nreach={1>0,tx>=0,$>=0,x>=y}
      do not widen

  ** processing vertex state_4 with widening:
    the old polyhedron is  {$>=0,1>0,tx>=0,tx+x+1>y} 
    the incoming hedges are not meta ones 
    dealing with hedge t_8_0 (coming from loc state_8)
    we apply the transfo to the poly {1>0,tx>=0,$>=0,x>=y} in the prec hedge
    contrib of hedge t_8_0 (coming from loc state_8) = constraints not available(3)
    dealing with hedge t_7_0 (coming from loc state_7)
    we apply the transfo to the poly {1>0,tx>=0,$>=0,x>=y} in the prec hedge
    contrib of hedge t_7_0 (coming from loc state_7) = constraints not available(3)
    the contributions from the preceeding nodes is  {tx>=0,tx+x+1>=y,$>=0,1>0} 
    nreach={1>0,tx>=0,$>=0,tx+x+1>=y}
     widen part :
    widening {$>=0,1>0,tx>=0,tx+x+1>y} by {1>0,tx>=0,$>=0,tx+x+1>=y} ? 
   nb of hedges = 3
    --upto : {tx<0,x<y,x<=y,$>=0,1>0,0,0,x>y,x>=y,tx>=0,0,0,0,0,0,0,0,0,0,0} --
    widening = {$>=0,1>0,tx>=0}

  ** processing vertex state_6 :
    the old polyhedron is  {1>0,tx>=0,$>=0,x>=y} 
    the incoming hedges are not meta ones 
    dealing with hedge t_4_0 (coming from loc state_4)
    we apply the transfo to the poly {$>=0,1>0,tx>=0} in the prec hedge
    contrib of hedge t_4_0 (coming from loc state_4) = {$>=0,1>0,tx>=0,x>=y}
    the contributions from the preceeding nodes is  {$>=0,1>0,tx>=0,x>=y} 
    reach= {1>0,tx>=0,$>=0,x>=y} 
    no change, the abstr value is still {1>0,tx>=0,$>=0,x>=y} 

  ** processing vertex state_8 :
    the old polyhedron is  {1>0,tx>=0,$>=0,x>=y} 
    the incoming hedges are not meta ones 
    dealing with hedge t_6_1 (coming from loc state_6)
    we apply the transfo to the poly {1>0,tx>=0,$>=0,x>=y} in the prec hedge
    contrib of hedge t_6_1 (coming from loc state_6) = {1>0,tx>=0,$>=0,x>=y}
    the contributions from the preceeding nodes is  {1>0,tx>=0,$>=0,x>=y} 
    reach= {1>0,tx>=0,$>=0,x>=y} 
    no change, the abstr value is still {1>0,tx>=0,$>=0,x>=y} 

  ** processing vertex state_7 :
    the old polyhedron is  {1>0,tx>=0,$>=0,x>=y} 
    the incoming hedges are not meta ones 
    dealing with hedge t_6_0 (coming from loc state_6)
    we apply the transfo to the poly {1>0,tx>=0,$>=0,x>=y} in the prec hedge
    contrib of hedge t_6_0 (coming from loc state_6) = {1>0,tx>=0,$>=0,x>=y}
    the contributions from the preceeding nodes is  {1>0,tx>=0,$>=0,x>=y} 
    reach= {1>0,tx>=0,$>=0,x>=y} 
    no change, the abstr value is still {1>0,tx>=0,$>=0,x>=y} 

  ** processing vertex state_4 with widening:
    the old polyhedron is  {$>=0,1>0,tx>=0} 
    the incoming hedges are not meta ones 
    dealing with hedge t_8_0 (coming from loc state_8)
    we apply the transfo to the poly {1>0,tx>=0,$>=0,x>=y} in the prec hedge
    contrib of hedge t_8_0 (coming from loc state_8) = constraints not available(3)
    dealing with hedge t_7_0 (coming from loc state_7)
    we apply the transfo to the poly {1>0,tx>=0,$>=0,x>=y} in the prec hedge
    contrib of hedge t_7_0 (coming from loc state_7) = constraints not available(3)
    the contributions from the preceeding nodes is  {tx>=0,tx+x+1>=y,$>=0,1>0} 
    reach= {1>0,tx>=0,$>=0} 
    no change, the abstr value is still {$>=0,1>0,tx>=0} 

  ** processing vertex state_6 :
    the old polyhedron is  {1>0,tx>=0,$>=0,x>=y} 
    the incoming hedges are not meta ones 
    dealing with hedge t_4_0 (coming from loc state_4)
    we apply the transfo to the poly {$>=0,1>0,tx>=0} in the prec hedge
    contrib of hedge t_4_0 (coming from loc state_4) = {$>=0,1>0,tx>=0,x>=y}
    the contributions from the preceeding nodes is  {$>=0,1>0,tx>=0,x>=y} 
    reach= {1>0,tx>=0,$>=0,x>=y} 
    no change, the abstr value is still {1>0,tx>=0,$>=0,x>=y} 

  ** processing vertex state_8 :
    the old polyhedron is  {1>0,tx>=0,$>=0,x>=y} 
    the incoming hedges are not meta ones 
    dealing with hedge t_6_1 (coming from loc state_6)
    we apply the transfo to the poly {1>0,tx>=0,$>=0,x>=y} in the prec hedge
    contrib of hedge t_6_1 (coming from loc state_6) = {1>0,tx>=0,$>=0,x>=y}
    the contributions from the preceeding nodes is  {1>0,tx>=0,$>=0,x>=y} 
    reach= {1>0,tx>=0,$>=0,x>=y} 
    no change, the abstr value is still {1>0,tx>=0,$>=0,x>=y} 

  ** processing vertex state_7 :
    the old polyhedron is  {1>0,tx>=0,$>=0,x>=y} 
    the incoming hedges are not meta ones 
    dealing with hedge t_6_0 (coming from loc state_6)
    we apply the transfo to the poly {1>0,tx>=0,$>=0,x>=y} in the prec hedge
    contrib of hedge t_6_0 (coming from loc state_6) = {1>0,tx>=0,$>=0,x>=y}
    the contributions from the preceeding nodes is  {1>0,tx>=0,$>=0,x>=y} 
    reach= {1>0,tx>=0,$>=0,x>=y} 
    no change, the abstr value is still {1>0,tx>=0,$>=0,x>=y} 

  End Processing strategy [(state_4,[t_8_0,t_7_0,t_3_0],true);
                           (state_6,[t_4_0],false); (state_8,[t_6_1],false);
                           (state_7,[t_6_0],false)]
  Sum up of the looping step (4 iteration(s))
    acc(state_4)={$>=0,1>0,tx>=0}
    acc(state_6)={1>0,tx>=0,$>=0,x>=y}
    acc(state_8)={1>0,tx>=0,$>=0,x>=y}
    acc(state_7)={1>0,tx>=0,$>=0,x>=y}

  ** processing vertex state_2 :
    the old polyhedron is  empty(3) 
    the incoming hedges are not meta ones 
    dealing with hedge t_5_0 (coming from loc state_5)
    we apply the transfo to the poly {1>0,$>=0} in the prec hedge
    contrib of hedge t_5_0 (coming from loc state_5) = {1>0,$>=0}
    dealing with hedge t_4_1__tsplit1 (coming from loc state_4)
    we apply the transfo to the poly {$>=0,1>0,tx>=0} in the prec hedge
    dealing with hedge t_4_1__tsplit0 (coming from loc state_4)
    we apply the transfo to the poly {$>=0,1>0,tx>=0} in the prec hedge
    contrib of hedge t_4_1__tsplit0 (coming from loc state_4) = {$>=0,1>0,
                                                                 tx>=0,x<y}
    the contributions from the preceeding nodes is  {1>0,$>=0} 
    nreach={$>=0,1>0}

  End Processing strategy [(state_1,[],false); (state_3,[t_1_0],false);
                           (state_5,[t_3_1__tsplit1,t_3_1__tsplit0],false);
                           [(state_4,[t_8_0,t_7_0,t_3_0],true);
                            (state_6,[t_4_0],false); (state_8,[t_6_1],false);
                            (state_7,[t_6_0],false)];
                           (state_2,[t_5_0,t_4_1__tsplit1,t_4_1__tsplit0],false)]
  Sum up of the looping step (1 iteration(s))
    acc(state_1)={$>=0,1>0}
    acc(state_3)={$>=0,1>0}
    acc(state_5)={1>0,$>=0}
    acc(state_4)={$>=0,1>0,tx>=0}
    acc(state_6)={1>0,tx>=0,$>=0,x>=y}
    acc(state_8)={1>0,tx>=0,$>=0,x>=y}
    acc(state_7)={1>0,tx>=0,$>=0,x>=y}
    acc(state_2)={$>=0,1>0}

   *  Invariants =  
state_1 -----> {true} 

state_2 -----> {true} 

state_3 -----> {true} 

state_4 -----> {tx>=0} 

state_5 -----> {true} 

state_6 -----> {x>=y, tx>=0} 

state_7 -----> {x>=y, tx>=0} 

state_8 -----> {x>=y, tx>=0} 
